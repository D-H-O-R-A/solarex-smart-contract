"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_env_1 = require("hardhat/internal/core/config/config-env");
require("./type-extensions");
const compile_1 = require("./compile");
const utils_1 = require("./utils");
const ARTIFACT_FORMAT_VERSION = 'hh-zksolc-artifact-1';
(0, config_env_1.extendConfig)((config) => {
    const defaultConfig = {
        version: 'latest',
        compilerSource: 'binary',
        settings: {
            optimizer: {
                enabled: false,
            },
            experimental: {},
        },
    };
    config.zksolc = Object.assign(Object.assign({}, defaultConfig), config.zksolc);
    config.zksolc.settings = Object.assign(Object.assign({}, defaultConfig.settings), config.zksolc.settings);
    // TODO: If solidity optimizer is not enabled, the libraries are not inlined and
    // we have to manually pass them into zksolc. So for now we force the optimization.
    config.solidity.compilers.forEach((compiler) => {
        let settings = compiler.settings || {};
        compiler.settings = Object.assign(Object.assign({}, settings), { optimizer: { enabled: true } });
    });
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, async ({ sourceName, contractName, contractOutput, }) => {
    var _a, _b, _c, _d;
    let bytecode = ((_b = (_a = contractOutput.evm) === null || _a === void 0 ? void 0 : _a.bytecode) === null || _b === void 0 ? void 0 : _b.object) || ((_d = (_c = contractOutput.evm) === null || _c === void 0 ? void 0 : _c.deployedBytecode) === null || _d === void 0 ? void 0 : _d.object) || '';
    bytecode = (0, utils_1.zeroxlify)(bytecode);
    let factoryDeps = {};
    let entries = Object.entries(contractOutput.factoryDependencies || {});
    for (const [hash, dependency] of entries) {
        factoryDeps[(0, utils_1.zeroxlify)(hash)] = dependency;
    }
    return {
        _format: ARTIFACT_FORMAT_VERSION,
        contractName,
        sourceName,
        abi: contractOutput.abi,
        // technically, zkEVM has no difference between bytecode & deployedBytecode,
        // but both fields are included just in case
        bytecode,
        deployedBytecode: bytecode,
        // zksolc does not support unlinked objects,
        // all external libraries are either linked during compilation or inlined
        linkReferences: {},
        deployedLinkReferences: {},
        // zkSync-specific field
        factoryDeps,
    };
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, async ({ input }, { config }) => {
    if (config.zksolc.settings.libraries) {
        input.settings.libraries = config.zksolc.settings.libraries;
    }
    return await (0, compile_1.compile)(config.zksolc, input);
});
// This task searches for the required solc version in the system and downloads it if not found.
// zksolc currently uses solc found in $PATH so this task is not needed for the most part.
// It is overriden to prevent unnecessary downloads.
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, async (args) => {
    // return dummy value, it's not used anywhere anyway
    return {
        compilerPath: '',
        isSolsJs: false,
        version: args.solcVersion,
        longVersion: args.solcVersion,
    };
});
//# sourceMappingURL=index.js.map